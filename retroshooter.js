function Projectile(x, y, strength, owner) {
  this.x = x || 0
  this.y = y || 0
  this.strength = strength || 5
  this.owner = owner || "player"
  this.destroyed = false
  this.direction = 1  // can be -1 for enemy projectiles

  this.boundaries = function() {
    r = strength / 2.0
    return {
      x: x - r,
      y: y - r,
      x2: x + r,
      y2: y + r
    }
  }
}

function Ship(x, y, name, colour, multiplicator, baseSize) {
  if ( !(this instanceof Ship) ) return new Ship()

  this.x = x || 0
  this.y = y || 0
  this.name = name || "enemy"
  this.colour = colour || "#F00"
  this.multiplicator = multiplicator || 1
  this.baseHitpoints = 100 * this.multiplicator
  this.hitpoints = this.baseHitpoints
  this.destroyed = false
  this.baseSize = (20 || baseSize) * this.multiplicator
  this.boundaries = function() {
    return {
      x: this.x,
      y: this.y,
      x2: this.x + this.baseSize,
      y2: this.y + this.baseSize
    }
  }
  this.collides_with = function(boundaries) {
    var own_boundaries = this.boundaries(),
        left1 = own_boundaries.x,
        left2 = boundaries.x,
        right1 = own_boundaries.x2,
        right2 = boundaries.x2,
        top1 = own_boundaries.y,
        top2 = boundaries.y,
        bottom1 = own_boundaries.y2,
        bottom2 = boundaries.y2

    if(right1 < left2 || left1 > right2) return false
    if(bottom1 < top2 || top1 > bottom2) return false
    return true
  }

  this.hit = function(points) {
    this.hitpoints -= points
    if (this.hitpoints <= 0) {
      this.destroyed = true
      this.hitpoints = 0
    }
  }

  this.up    = function() {if(this.y > 20) this.y -= 4 }
  this.left  = function() {if(this.x > 4) this.x -= 4 }
  this.down  = function() {if(this.y < 476) this.y += 4 }
  this.right = function() {if(this.x < 396) this.x += 4 }
}


function draw_enemy(ship) {
  ctx.globalAlpha = ship.hitpoints*1.0 / ship.baseHitpoints
  ctx.fillStyle = ship.colour
  ctx.strokeStyle = ship.colour
  ctx.beginPath()
  ctx.moveTo(ship.x, ship.y)
  ctx.lineTo(ship.x + ship.baseSize, ship.y)
  ctx.lineTo(ship.x + ship.baseSize/2.0, ship.y + ship.baseSize)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha = 1.0
  ctx.stroke()
}

function draw_projectile(projectile) {
  ctx.globalAlpha = 1.0
  ctx.fillStyle = "#FF0"
  ctx.beginPath()
  ctx.arc(projectile.x, projectile.y, projectile.strength, 0, Math.PI*2, true)
  ctx.fill()
}

function draw_player(ship) {
  ctx.globalAlpha = ship.hitpoints*1.0 / ship.baseHitpoints
  ctx.fillStyle = ship.colour
  ctx.strokeStyle = ship.colour
  ctx.beginPath();  
  ctx.arc(
    ship.x , ship.y,
    ship.baseSize,
    Math.PI*0.5+0.8, Math.PI*0.5-0.8,
    false
  );
  ctx.closePath()
  ctx.fill();  
  ctx.globalAlpha = 1.0
  ctx.stroke()
}

function run(ctx) {
  var lvl = 0,
      lvlIndicator = document.getElementById('level'),
      hitpointIndicator = document.getElementById('hitpoints'),
      projectileBaseSize = 5,
      projectileTreshold = 20,
      playerBaseSize = 15,
      enemyBaseSize = 20,
      enemies = [],
      projectiles = [],
      player = new Ship(200, 470, "player", "#0F0", 1.0, playerBaseSize)

  function obsolet_ship(element, index, array) {
    return (element.y <= 480 && !element.destroyed)
  }

  function obsolet_projectile(element, index, array) {
    return (element.y >= 0 && !element.destroyed)
  }

  function generateProjectile(owner) {
    if(projectiles.length <= projectileTreshold) {
      projectile = new Projectile(owner.x, owner.y, 5, owner)
      projectiles.push(projectile)
    }
  }

  /**
   * Enemy Generator
   *
   * Enemies are generated by according to the current level:
   * The decade is used for the number of ships generated each cycle.
   * The units are used to calculate the time until the next cycle.
   */
  function generateEnemies() {
    var r, x,
        decade = Math.floor(lvl/10) + 1
        units = (lvl % 10)
        count = decade
        time = 2000 - units*100  // slow at the beginning, fast at the end

    for(;count;count--) {
      var r = Math.random()
      var x = Math.random()*400 % 380
      if (r > 0.1) enemies.push(new Ship(x, -20))
      else enemies.push(new Ship(x, -50, "boss", "#F50", 3))
    }
    setTimeout(generateEnemies, time)
  }

  function doKeyDown(evt){
    if (evt.keyCode == 37) player.left()  // left
    if (evt.keyCode == 38) player.up()    // up
    if (evt.keyCode == 39) player.right() // right
    if (evt.keyCode == 40) player.down()  // down
    if (evt.keyCode == 32) generateProjectile(player)   // shoot!
  }

  function cleanup() {
    // cleanup lost enemies
    enemies = enemies.filter(obsolet_ship)
    // cleanup lost bullets
    projectiles = projectiles.filter(obsolet_projectile)
  }

  function collison_detection() {
    for(i in enemies) {
      enemy = enemies[i]

      // look for projectiles hitting enemies
      for(i in projectiles) {
        projectile = projectiles[i]
        boundaries = {
          x: projectile.x,
          y: projectile.y,
          x2: projectile.x,
          y2: projectile.y
        }
        if(enemy.collides_with(boundaries)) {
          enemy.hit(projectile.strength)
          projectile.destroyed = true
        }
      }

      // look for enemies hitting the player
      if(enemy.collides_with(player.boundaries())) {
        enemy.hit(100)
        player.hit(5)
      }
    }
  }

  function render() {
    lvlIndicator.innerHTML = lvl
    hitpointIndicator.innerHTML = player.hitpoints

    ctx.clearRect(0,0,640,480)

    // TODO: should be way faster to draw every ship type once and just copy it
    for(i in enemies) {
      draw_enemy(enemies[i])
      enemies[i].y += 2.0 / enemies[i].multiplicator
    }

    draw_player(player)
    for(i in projectiles) {
      draw_projectile(projectiles[i])
      projectiles[i].y -= (4.0 * projectiles[i].direction)
    }

    cleanup()
    collison_detection()
  }

  function raiseLevel() { lvl++ }

  ctx.globalCompositeOperation = 'destination-over'
  window.addEventListener('keydown', doKeyDown, false)
  enemyInterval = setTimeout(generateEnemies, 2000)
  renderInterval = setInterval(render, 20)
  raiseLevelInterval = setInterval(raiseLevel, 10000)
}


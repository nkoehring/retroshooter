function Projectile(x, y, strength, owner) {
  this.x = x || 0
  this.y = y || 0
  this.strength = strength || 5
  this.owner = owner || "player"
  this.destroyed = false
  this.direction = 1  // can be -1 for enemy projectiles

  this.boundaries = function() {
    r = strength / 2.0
    return {
      x: x - r,
      y: y - r,
      x2: x + r,
      y2: y + r
    }
  }
}

function Ship(x, y, name, colour, multiplicator, baseSize) {
  if ( !(this instanceof Ship) ) return new Ship()

  this.x = x || 0
  this.y = y || 0
  this.name = name || "enemy"
  this.colour = colour || "#F00"
  this.multiplicator = multiplicator || 1
  this.baseHitpoints = 100 * this.multiplicator
  this.hitpoints = this.baseHitpoints
  this.destroyed = false
  this.baseSize = (20 || baseSize) * this.multiplicator
  this.boundaries = function() {
    return {
      x: this.x,
      y: this.y,
      x2: this.x + this.baseSize,
      y2: this.y + this.baseSize
    }
  }
  this.collides_with = function(boundaries) {
    var own_boundaries = this.boundaries(),
        left1 = own_boundaries.x,
        left2 = boundaries.x,
        right1 = own_boundaries.x2,
        right2 = boundaries.x2,
        top1 = own_boundaries.y,
        top2 = boundaries.y,
        bottom1 = own_boundaries.y2,
        bottom2 = boundaries.y2

    if(right1 < left2 || left1 > right2) return false
    if(bottom1 < top2 || top1 > bottom2) return false
    return true
  }

  this.hit = function(points) {
    this.hitpoints -= points
    if (this.hitpoints <= 0) {
      this.destroyed = true
      this.hitpoints = 0
    }
  }
}


function draw_enemy(ship) {
  ctx.globalAlpha = ship.hitpoints*1.0 / ship.baseHitpoints
  ctx.fillStyle = ship.colour
  ctx.strokeStyle = ship.colour
  ctx.beginPath()
  ctx.moveTo(ship.x, ship.y)
  ctx.lineTo(ship.x + ship.baseSize, ship.y)
  ctx.lineTo(ship.x + ship.baseSize/2.0, ship.y + ship.baseSize)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha = 1.0
  ctx.stroke()
}

function draw_projectile(projectile) {
  ctx.globalAlpha = 1.0
  ctx.fillStyle = "#FF0"
  ctx.beginPath()
  ctx.arc(projectile.x, projectile.y, projectile.strength, 0, Math.PI*2, true)
  ctx.fill()
}

function draw_player(ship) {
  ctx.globalAlpha = ship.hitpoints*1.0 / ship.baseHitpoints
  ctx.fillStyle = ship.colour
  ctx.strokeStyle = ship.colour
  ctx.beginPath();  
  ctx.arc(
    ship.x , ship.y,
    ship.baseSize,
    Math.PI*0.5+0.8, Math.PI*0.5-0.8,
    false
  );
  ctx.closePath()
  ctx.fill();  
  ctx.globalAlpha = 1.0
  ctx.stroke()
}

function run(ctx) {
  var lvl = 0,
      lvlIndicator = document.getElementById('level'),
      hitpointIndicator = document.getElementById('hitpoints'),
      projectileBaseSize = 5,
      projectileTreshold = 20,
      playerBaseSize = 15,
      enemyBaseSize = 20,
      enemies = [],
      projectiles = [],
      player = new Ship(200, 470, "player", "#0F0", 1.0, playerBaseSize),
      keyMapping = {
        37: "player.acceleration.h-=4",    // left
        38: "player.acceleration.v-=4",    // up
        39: "player.acceleration.h+=4",    // right
        40: "player.acceleration.v+=4",    // down
        32: "generateProjectile(player)"  // shoot!
        //80: "pause()"
      }

  player.acceleration = {h:0, v:0}


  function obsolet_ship(element, index, array) {
    return (element.y <= 480 && !element.destroyed)
  }

  function obsolet_projectile(element, index, array) {
    return (element.y >= 0 && !element.destroyed)
  }

  function generateProjectile(owner) {
    if(projectiles.length <= projectileTreshold) {
      projectile = new Projectile(owner.x, owner.y, 5, owner)
      projectiles.push(projectile)
    }
  }

  /**
   * Enemy Generator
   *
   * Enemies are generated by according to the current level:
   * The decade is used for the number of ships generated each cycle.
   * The units are used to calculate the time until the next cycle.
   */
  function generateEnemies() {
    var r, x,
        decade = Math.floor(lvl/10) + 1
        units = (lvl % 10)
        count = decade
        time = 2000 - units*100  // slow at the beginning, fast at the end

    for(;count;count--) {
      var r = Math.random()
      var x = Math.random()*400 % 380
      if (r > 0.1) enemies.push(new Ship(x, -20))
      else enemies.push(new Ship(x, -50, "boss", "#F50", 3))
    }
    setTimeout(generateEnemies, time)
  }

  function doKeyDown(evt){
    if (!(evt.keyCode in keyMapping)) return

    evt.preventDefault()
    eval(keyMapping[evt.keyCode])  // oh damn, use function.call or something!
  }

  function cleanup() {
    // cleanup lost enemies
    enemies = enemies.filter(obsolet_ship)
    // cleanup lost bullets
    projectiles = projectiles.filter(obsolet_projectile)
  }

  function collison_detection() {
    for(i in enemies) {
      enemy = enemies[i]

      // look for projectiles hitting enemies
      for(i in projectiles) {
        projectile = projectiles[i]
        boundaries = {
          x: projectile.x,
          y: projectile.y,
          x2: projectile.x,
          y2: projectile.y
        }
        if(enemy.collides_with(boundaries)) {
          enemy.hit(projectile.strength)
          projectile.destroyed = true
        }
      }

      // look for enemies hitting the player
      if(enemy.collides_with(player.boundaries())) {
        enemy.hit(100)
        player.hit(5)
      }
    }
  }

  function calc_player_acceleration() {
    h = player.acceleration.h
    v = player.acceleration.v
    player.x += h/10.0
    player.y += v/10.0
    
    if(player.x < 4) player.x = 4
    if(player.x > 396) player.x = 396
    if(player.y < 20) player.y = 20
    if(player.y > 476) player.y = 476

    if(h != 0) h<0 ? h++ : h--
    if(v != 0) v<0 ? v++ : v--

    player.acceleration.h = h
    player.acceleration.v = v
  }

  function render() {
    lvlIndicator.innerHTML = lvl
    hitpointIndicator.innerHTML = player.hitpoints
    hAccelIndicator.innerHTML = player.acceleration.h
    vAccelIndicator.innerHTML = player.acceleration.v

    ctx.clearRect(0,0,640,480)

    // TODO: should be way faster to draw every ship type once and just copy it
    for(i in enemies) {
      draw_enemy(enemies[i])
      enemies[i].y += 2.0 / enemies[i].multiplicator
    }

    draw_player(player)
    for(i in projectiles) {
      draw_projectile(projectiles[i])
      projectiles[i].y -= (4.0 * projectiles[i].direction)
    }

    cleanup()
    collison_detection()
    calc_player_acceleration()
  }

  function raiseLevel() { lvl++ }

  ctx.globalCompositeOperation = 'destination-over'
  window.addEventListener('keydown', doKeyDown, false)
  window.enemyInterval = setTimeout(generateEnemies, 2000)
  window.renderInterval = setInterval(render, 20)
  window.raiseLevelInterval = setInterval(raiseLevel, 10000)
}

